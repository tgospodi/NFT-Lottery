// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {VRFConsumerBase} from "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
import {LinkTokenInterface} from "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol";

error Draft__NotEnoughLINK();
error Draft__CallbackFailed();

/**
 * @title Draft
 * @notice VRFConsumer contract providing VRF Randomness
 *
 */

contract Draft is VRFConsumerBase {
    bytes32 internal keyHash;
    uint256 public fee;
    address internal immutable vrfCoordinator;
    LinkTokenInterface internal immutable link;

    // requester (requestId) to contract address of the requester
    mapping(bytes32 => address) internal requesters;
    // requester (requestId) to callback function that they have requested
    mapping(bytes32 => string) public requests;

    constructor(address _vrfCoordinator, address _link, bytes32 _keyHash) VRFConsumerBase(_vrfCoordinator, _link) {
        vrfCoordinator = _vrfCoordinator;
        link = LinkTokenInterface(_link);
        keyHash = _keyHash;
        fee = 0.1 * 10e18; // 0.1 LINK fee
    }

    /**
     * @notice Requests randomness from a user-provided seed
     * @param callbackFunction The function that will be called when the random number is generated
     * @notice Stores the requesters address and the callback function they want to be called when the random number is generated
     */
    function getRandomNumber(string memory callbackFunction) public returns (bytes32 requestId) {
        if (link.balanceOf(address(this)) < fee) {
            revert Draft__NotEnoughLINK();
        }
        requestId = requestRandomness(keyHash, fee);
        requesters[requestId] = msg.sender; // who was the requester
        requests[requestId] = callbackFunction; // what they requested
        return requestId;
    }

    /**
     * @notice Callback function that will be invoked with the random number
     * @param requestId  The id of the request
     * @param randomness  The random number generated by the VRF
     */
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        (bool success,) = requesters[requestId].call(abi.encodeWithSignature(requests[requestId], randomness));
        if (!success) {
            revert Draft__CallbackFailed();
        }
    }
}
